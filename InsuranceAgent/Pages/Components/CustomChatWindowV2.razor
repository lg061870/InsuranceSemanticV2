@using System.Collections.Generic
@using System.Text.Json
@using ConversaCore.Events
@using ConversaCore.Interfaces
@using ConversaCore.Models
@using ConversaCore.Services
@using ConversaCore.TopicFlow
@using InsuranceAgent.Models
@using InsuranceAgent.Services

@implements IDisposable

@inject HybridChatService ChatService
@inject IChatInteropService ChatInteropService
@inject NavigationManager NavigationManager
@inject IJSRuntime JSRuntime
@inject ILogger<CustomChatWindowV2> Logger

<!-- ========== CHAT WINDOW LAYOUT ========== -->
<div class="chat-window-container">

    <!-- Header -->
    <div class="chat-header">
        <div class="chat-header-avatar">
            <div class="avatar-circle">
                <img src="https://storage.googleapis.com/uxpilot-auth.appspot.com/avatars/avatar-ai-1.jpg" alt="Sofia" />
                <div class="avatar-status"></div>
            </div>
        </div>
        <div class="chat-header-info">
            <h3 class="chat-header-name">Sofia</h3>
            <div class="chat-header-status">
                <div class="status-indicator"></div>
                <span>V2 -- AI Assistant • Online</span>
            </div>
        </div>
        <div class="chat-header-actions">
            <button class="chat-header-button" title="Reset conversation" @onclick="ConfirmReset">
                <i class="fa-solid fa-rotate-left"></i>
            </button>
            <button class="chat-header-button" title="Clear chat" @onclick="ClearChat">
                <i class="fa-solid fa-trash-can"></i>
            </button>
        </div>
    </div>

    <!-- Message history -->
    <div class="messages-container" @ref="messagesContainerRef">
        @foreach (var message in Messages) {
            @if (message.IsFromUser) {
                <!-- User messages -->
                <div class="message-group">
                    <div class="message user-message">
                        <div class="message-content">@message.Content</div>
                        <div class="message-time">@message.Timestamp.ToString("h:mm tt")</div>
                        <div class="message-actions">
                            <button class="message-action-button" title="Edit" @onclick="() => EditMessage(message)">
                                <i class="fa-solid fa-pen"></i>
                            </button>
                        </div>
                    </div>
                </div>
            }
            else {
                <!-- Bot messages -->
                <div class="message-group">
                    <div class="message bot-message">

                        @if (message.IsAdaptiveCard && !string.IsNullOrEmpty(message.AdaptiveCardJson)) {
                            <!-- Adaptive Card -->
                            <div class="adaptive-card-container @(message.IsActive ? "" : "readonly")">
                                <AdaptiveCardRenderer CardJson="@message.AdaptiveCardJson"
                                                      CardContainerId="@($"card-{message.Timestamp.Ticks}")"
                                                      Disabled="@(!message.IsActive)"
                                                      OnSubmit="OnAdaptiveCardSubmit"
                                                      OnAction="HandleCardAction" />

                            </div>

                            <div class="message-time">@message.Timestamp.ToString("h:mm tt")</div>
                        }
                        else {
                            <!-- Plain text message -->
                            <div class="message-content">@((MarkupString)FormatMessageContent(message.Content))</div>
                            <div class="message-time">@message.Timestamp.ToString("h:mm tt")</div>
                            <div class="message-actions">
                                <button class="message-action-button" title="Copy" @onclick="() => CopyMessageToClipboard(message)">
                                    <i class="fa-solid fa-copy"></i>
                                </button>
                            </div>
                        }
                    </div>
                </div>
            }
        }

        <!-- Typing indicator -->
        @if (IsTyping) {
            <div class="message bot-message typing-indicator">
                <span></span>
                <span></span>
                <span></span>
            </div>
        }
    </div>

    <!-- Suggestion chips -->
    <div class="chat-suggestions @( !IsPromptEnabled ? "disabled" : "" )">
        @foreach (var suggestion in CurrentSuggestions) {
            <div class="suggestion-chip"
                 @onclick="() => UseSuggestion(suggestion)"
                 disabled="@(!IsPromptEnabled)">
                @suggestion
            </div>
        }
    </div>

    <!-- Message input -->
    <div class="message-input-container" title="@(!IsPromptEnabled ? "Please complete the required card above before continuing." : null)">
        <textarea @bind="CurrentMessage"
                  @bind:event="oninput"
                  @onkeydown="HandleKeyDown"
                  placeholder="@(!IsPromptEnabled
                                      ? "Please complete the required card above before continuing..."
                                      : "Type your message...")"
                  disabled="@(!IsPromptEnabled || IsProcessing)"
                  class="message-input @( !IsPromptEnabled ? "disabled" : "" )"
                  rows="1"
                  @ref="messageInputRef"></textarea>

        <button class="send-button"
                @onclick="SendMessage"
                disabled="@(!IsPromptEnabled || IsProcessing || string.IsNullOrWhiteSpace(CurrentMessage))">
            <i class="fa-solid fa-paper-plane"></i>
        </button>
    </div>

</div>

<!-- Reset Confirmation Dialog -->
@if (showResetConfirmation) {
    <div class="modal-overlay" @onclick="HideResetConfirmation">
        <div class="modal-dialog" @onclick:stopPropagation="true">
            <div class="modal-header">
                <h3>Reset Conversation</h3>
                <button class="modal-close" @onclick="HideResetConfirmation">
                    <i class="fa-solid fa-times"></i>
                </button>
            </div>
            <div class="modal-body">
                <p>Are you sure you want to reset the entire conversation?</p>
                <p><strong>This will:</strong></p>
                <ul>
                    <li>Clear all chat history</li>
                    <li>Reset all form data and preferences</li>
                    <li>Start a completely fresh conversation</li>
                </ul>
                <p class="text-warning">This action cannot be undone.</p>
            </div>
            <div class="modal-footer">
                <button id="reset-cancel-btn" type="button" class="btn btn-secondary" @onclick="HideResetConfirmation">Cancel</button>
                <button id="reset-test-btn" type="button" class="btn btn-warning" @onclick="TestResetButton">Test Button</button>
                <button id="reset-confirm-btn" type="button" class="btn btn-danger" @onclick="ConfirmReset">Reset Conversation</button>
            </div>
        </div>
    </div>
}


@code {
    // ========== EVENTS ========== 
    public event EventHandler<MessageEventArgs>? UserMessageEntered;
    public event EventHandler<ChatCardSubmitEventArgs>? AdaptiveCardSubmitted;
    public event EventHandler<ChatWindowCardActionEventArgs>? CardActionInvoked;
    public event EventHandler<ChatWindowBotMessageEventArgs>? BotMessageRendered;

    // ========== STATE ========== 
    private ChatSessionState SessionState { get; set; } = new ChatSessionState();
    private List<ChatMessage> Messages { get; set; } = new();
    private string CurrentMessage { get; set; } = "";
    private bool IsTyping { get; set; } = false;
    private bool IsProcessing { get; set; } = false;
    private ChatMessage? messageBeingEdited = null;
    private bool _conversationStarted = false;
    private bool showResetConfirmation = false;
    private bool IsPromptEnabled { get; set; } = true;

    private ElementReference messagesContainerRef;
    private ElementReference messageInputRef;

    private List<string> CurrentSuggestions { get; set; } = new() {
        "California Resident",
        "Beneficiary info",
        "repeat demo"
    };

    // public TopicWorkflowContextV2 WorkflowContext { get; set; } = default!;

    protected override async Task OnAfterRenderAsync(bool firstRender) {
        if (firstRender && !_conversationStarted) {
            // Subscribe Service → ChatWindow FIRST
            ChatService.HybridBotMessageReady += (s, e) => {
                Logger?.LogInformation($"[ChatWindow] Received HybridBotMessageReady: {e.Message.Content}");
                InvokeAsync(() => {
                    Messages.Add(e.Message);
                    StateHasChanged();
                });

                BotMessageRendered?.Invoke(this, new ChatWindowBotMessageEventArgs(e.Message.Content));
            };

            ChatService.HybridAdaptiveCardReady += (s, e) => {
                Logger?.LogInformation($"[ChatWindow] HybridAdaptiveCardReady: CardId={e.CardId}, RenderMode={e.RenderMode}");
                InvokeAsync(() => {
                    if (e.RenderMode == ConversaCore.Events.RenderMode.Replace && !string.IsNullOrEmpty(e.CardId)) {
                        var existing = Messages.FirstOrDefault(m => m.IsAdaptiveCard && m.CardId == e.CardId);
                        if (existing != null) {
                            existing.AdaptiveCardJson = e.CardJson;
                            existing.Timestamp = DateTime.Now;
                            StateHasChanged();
                            Logger?.LogInformation($"[ChatWindow] AdaptiveCard replaced: CardId={e.CardId}");
                            return;
                        }
                    }

                    // fallback: append new card
                    Messages.Add(new ChatMessage {
                        IsFromUser = false,
                        IsAdaptiveCard = true,
                        AdaptiveCardJson = e.CardJson,
                        CardId = e.CardId,
                        Timestamp = DateTime.Now
                    });

                    StateHasChanged();
                    Logger?.LogInformation($"[ChatWindow] AdaptiveCard appended: CardId={e.CardId}");
                });
            };

            ChatService.HybridTypingIndicatorChanged += (s, e) => {
                Logger?.LogInformation($"[ChatWindow] TypingIndicatorChanged: IsTyping={e.IsTyping}");
                InvokeAsync(() => {
                    IsTyping = e.IsTyping;
                    StateHasChanged();
                });
            };

            ChatService.HybridSuggestionsUpdated += (s, e) => {
                Logger?.LogInformation($"[ChatWindow] SuggestionsUpdated: {string.Join(", ", e.Suggestions)}");
                InvokeAsync(() => {
                    CurrentSuggestions = e.Suggestions.ToList();
                    StateHasChanged();
                });
            };

            ChatService.HybridChatEventRaised += (s, e) => {
                Logger?.LogInformation($"[ChatWindow] ChatEventRaised: {e.ChatEvent?.Type}");
                InvokeAsync(() => {
                    HandleWorkflowEvent(e.ChatEvent);
                    StateHasChanged();
                });
            };

            ChatService.OnConversationReset += (s, e) => {
                Logger?.LogInformation($"[ChatWindow] OnConversationReset event received at {e.ResetTime}");
                Logger?.LogInformation($"[ChatWindow] Clearing {Messages.Count} messages");
                InvokeAsync(() => {
                    Messages.Clear();
                    Logger?.LogInformation("[ChatWindow] Messages cleared, calling StateHasChanged");
                    StateHasChanged();
                    Logger?.LogInformation("[ChatWindow] StateHasChanged completed");
                });

            };

            ChatService.HybridCardStateChanged += (s, e) => {
                Logger?.LogInformation($"[ChatWindow] Card state changed: {e.CardId} -> {e.State}");
                InvokeAsync(async () => {
                    var index = Messages.FindIndex(m => m.IsAdaptiveCard && m.CardId == e.CardId);
                    if (index != -1) {
                        var card = Messages[index];
                        bool newIsActive = e.State == CardState.Active;

                        if (card.IsActive != newIsActive) {
                            Logger?.LogInformation($"[ChatWindow] Updating card {e.CardId} active={newIsActive}");
                            card.IsActive = newIsActive;

                            // Force Blazor to detect the list mutation
                            Messages[index] = card;
                            StateHasChanged();

                            // ✅ Scroll logic: if card became active → scroll to bottom
                            if (newIsActive) {
                                Logger?.LogInformation($"[ChatWindow] Scrolling to bottom after activating {e.CardId}");
                                await ChatInteropService.ScrollToBottomAsync(messagesContainerRef);
                            }
                        }
                    }
                });
            };

            ChatService.PromptInputStateChanged += (s, e) => {
                Logger?.LogInformation($"[ChatWindow] Prompt state changed: Enabled={e.IsEnabled} (CardId={e.CardId})");
                InvokeAsync(() => {
                    IsPromptEnabled = e.IsEnabled;
                    StateHasChanged();
                });
            };

            // Subscribe ChatWindow → Service
            UserMessageEntered += ChatService.HandleUserMessage;
            BotMessageRendered += ChatService.HandleBotMessage;
            AdaptiveCardSubmitted += ChatService.HandleCardSubmit;
            CardActionInvoked += ChatService.HandleCardAction;

            // NOW safe to start the conversation
            ChatService.OnConversationStart += HandleConversationStart;
            ChatService.StartConversation(SessionState);

            _conversationStarted = true;
        }
    }

    private async void ScrollToCard(string cardId) {
        try {
            await JSRuntime.InvokeVoidAsync("scrollToCardElement", cardId);
        } catch (Exception ex) {
            Logger?.LogError(ex, "[ChatWindow] ScrollToCard failed for {CardId}", cardId);
        }
    }

    public void Dispose() {
        ChatService.OnConversationStart -= HandleConversationStart;
    }

    // ========== CONVERSATION ========== 
    private async void HandleConversationStart(ChatSessionState sessionState, ConversaCore.Topics.ITopic topic) {
        Logger?.LogInformation("[ChatWindow] HandleConversationStart called");
        var result = await topic.ProcessMessageAsync("__init__", CancellationToken.None);
        Messages.Add(new ChatMessage {
            Content = result.Response,
            IsFromUser = false,
            Timestamp = DateTime.Now
        });
        StateHasChanged();
        await ChatInteropService.ScrollToBottomAsync(messagesContainerRef);
        Logger?.LogInformation("[ChatWindow] HandleConversationStart completed");
    }

    private async Task SendMessage() {
        if (string.IsNullOrWhiteSpace(CurrentMessage) || IsProcessing)
            return;

        Logger?.LogInformation($"[ChatWindow] SendMessage called: {CurrentMessage}");
        IsProcessing = true;

        var userMessage = new ChatMessage {
            Content = CurrentMessage,
            IsFromUser = true,
            Timestamp = DateTime.Now
        };

        // Add immediately to UI
        Messages.Add(userMessage);

        // Trigger event to service
        UserMessageEntered?.Invoke(this, new MessageEventArgs(CurrentMessage));

        CurrentMessage = "";
        StateHasChanged();
        await ChatInteropService.ScrollToBottomAsync(messagesContainerRef);

        IsProcessing = false;
        Logger?.LogInformation("[ChatWindow] SendMessage completed");
    }

    // ========== UTILITY ========== 
    private void ClearChat() {
        Logger?.LogInformation($"[ChatWindow] ClearChat called, clearing {Messages.Count} messages");
        Messages.Clear();
        StateHasChanged();
        Logger?.LogInformation("[ChatWindow] ClearChat completed");
    }

    private void ShowResetConfirmation() {
        Logger?.LogInformation("[ChatWindow] ShowResetConfirmation called - showing modal dialog");
        showResetConfirmation = true;
        StateHasChanged();
        Logger?.LogInformation("[ChatWindow] Modal dialog state updated");
    }

    private void HideResetConfirmation() {
        Logger?.LogInformation("[ChatWindow] HideResetConfirmation called - hiding modal dialog");
        showResetConfirmation = false;
        StateHasChanged();
        Logger?.LogInformation("[ChatWindow] Modal dialog hidden");
    }

    private void TestResetButton() {
        Logger?.LogInformation("[ChatWindow] TestResetButton called - button binding works!");
        Logger?.LogInformation($"[ChatWindow] TestResetButton: showResetConfirmation={showResetConfirmation}");
        showResetConfirmation = false;
        StateHasChanged();
        Logger?.LogInformation("[ChatWindow] TestResetButton completed - modal closed");
    }

    private async Task ConfirmReset() {
        Logger?.LogInformation("[ChatWindow] ConfirmReset called - starting reset process");
        Logger?.LogInformation($"[ChatWindow] ConfirmReset: showResetConfirmation={showResetConfirmation}");
        showResetConfirmation = false;
        StateHasChanged();

        try {
            Logger?.LogInformation("[ChatWindow] Calling ChatService.ResetConversationAsync()");

            // Ensure all existing messages are cleared first before the reset
            // This prevents UI glitches where old messages appear momentarily
            Messages.Clear();
            StateHasChanged();

            // Small delay to ensure UI updates before backend reset
            await Task.Delay(100);

            // Now call the reset
            await ChatService.ResetConversationAsync();

            Logger?.LogInformation("[ChatWindow] ResetConversationAsync completed");

            // Force another state update to ensure everything is refreshed
            StateHasChanged();
        } catch (Exception ex) {
            Logger?.LogError(ex, "[ChatWindow] Error resetting conversation");

            // Add an error message for the user
            Messages.Add(new ChatMessage {
                Content = "⚠️ There was an error resetting the conversation. Please try again.",
                IsFromUser = false,
                Timestamp = DateTime.Now
            });
            StateHasChanged();
        }
    }

    private async Task CopyMessageToClipboard(ChatMessage message) {
        if (message == null || string.IsNullOrEmpty(message.Content)) return;
        Logger?.LogInformation($"[ChatWindow] CopyMessageToClipboard called: {message.Content}");
        await JSRuntime.InvokeVoidAsync("navigator.clipboard.writeText", message.Content);
        await JSRuntime.InvokeVoidAsync("recordChatEvent", "message_copied", new { content = message.Content });
        Logger?.LogInformation("[ChatWindow] CopyMessageToClipboard completed");
    }

    private void EditMessage(ChatMessage message) {
        if (message == null) return;
        Logger?.LogInformation($"[ChatWindow] EditMessage called: {message.Content}");
        messageBeingEdited = message;
        CurrentMessage = message.Content;
        StateHasChanged();
        Logger?.LogInformation("[ChatWindow] EditMessage completed");
    }

    private string FormatMessageContent(string content) =>
        string.IsNullOrEmpty(content) ? string.Empty : content;

    private Task HandleCardAction(string actionId) {
        Logger?.LogInformation($"[ChatWindow] HandleCardAction called: {actionId}");
        CardActionInvoked?.Invoke(this, new ChatWindowCardActionEventArgs(actionId));
        Logger?.LogInformation("[ChatWindow] HandleCardAction completed");
        return Task.CompletedTask;
    }

    private async Task HandleKeyDown(KeyboardEventArgs e) {
        Logger?.LogInformation($"[ChatWindow] HandleKeyDown: Key={e.Key}, Shift={e.ShiftKey}");
        if (e.Key == "Enter" && !e.ShiftKey) {
            await SendMessage();
        }
    }

    private void UpdateSuggestions(List<string> suggestions) {
        CurrentSuggestions = suggestions ?? new();
        StateHasChanged();
    }

    private async Task UseSuggestion(string suggestion) {
        Logger?.LogInformation($"[ChatWindow] UseSuggestion called: {suggestion}");
        CurrentMessage = suggestion;
        await SendMessage();
        Logger?.LogInformation("[ChatWindow] UseSuggestion completed");
    }

    // Called by AdaptiveCardRenderer when a card is submitted
    private Task OnAdaptiveCardSubmit(Dictionary<string, object> data) {
        Logger?.LogInformation("[ChatWindow] OnAdaptiveCardSubmit called");
        AdaptiveCardSubmitted?.Invoke(this, new ChatCardSubmitEventArgs(data));
        Logger?.LogInformation("[ChatWindow] OnAdaptiveCardSubmit completed");
        return Task.CompletedTask;
    }

    // === Workflow event stub (expand later if needed) ===
    private void HandleWorkflowEvent(ChatEvent chatEvent) {
        Logger?.LogInformation($"[ChatWindow] Workflow event: {chatEvent?.Type}");
    }
}

<style>
    .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
    }

    .modal-dialog {
        background: white;
        border-radius: 8px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        max-width: 500px;
        width: 90%;
        max-height: 90vh;
        overflow-y: auto;
    }

    .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 1rem 1.5rem;
        border-bottom: 1px solid #e9ecef;
    }

        .modal-header h3 {
            margin: 0;
            font-size: 1.25rem;
            font-weight: 600;
        }

    .modal-close {
        background: none;
        border: none;
        font-size: 1.5rem;
        cursor: pointer;
        color: #6c757d;
        padding: 0;
        width: 2rem;
        height: 2rem;
        display: flex;
        align-items: center;
        justify-content: center;
    }

        .modal-close:hover {
            color: #dc3545;
        }

    .modal-body {
        padding: 1.5rem;
    }

        .modal-body p {
            margin-bottom: 1rem;
        }

        .modal-body ul {
            margin-bottom: 1rem;
            padding-left: 1.5rem;
        }

        .modal-body li {
            margin-bottom: 0.5rem;
        }

    .text-warning {
        color: #fd7e14;
        font-weight: 500;
    }

    .modal-footer {
        display: flex;
        justify-content: flex-end;
        gap: 0.5rem;
        padding: 1rem 1.5rem;
        border-top: 1px solid #e9ecef;
    }

    .btn {
        padding: 0.5rem 1rem;
        border: 1px solid transparent;
        border-radius: 4px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s ease;
    }

    .btn-secondary {
        background-color: #6c757d;
        border-color: #6c757d;
        color: white;
    }

        .btn-secondary:hover {
            background-color: #5a6268;
            border-color: #545b62;
        }

    .btn-danger {
        background-color: #dc3545;
        border-color: #dc3545;
        color: white;
    }

        .btn-danger:hover {
            background-color: #c82333;
            border-color: #bd2130;
        }

    .adaptive-card-container.readonly {
        opacity: 0.5;
        pointer-events: none;
        transition: opacity 0.3s ease;
    }

    .message-input.disabled {
        opacity: 0.6;
        cursor: not-allowed;
        background-color: #f4f4f4;
        color: #999;
    }

    .message-input-container[title] {
        position: relative;
    }

        .message-input-container[title]::after {
            content: attr(title);
            display: none;
            position: absolute;
            bottom: 120%;
            left: 10px;
            background: #333;
            color: #fff;
            font-size: 0.75rem;
            padding: 6px 8px;
            border-radius: 4px;
            white-space: nowrap;
            z-index: 200;
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
        }

        .message-input-container[title]:hover::after {
            display: block;
            opacity: 1;
        }

    /* === Required Card Styling === */
    .ac-required-card {
        position: relative;
        border: 2px solid #ffb84d;
        border-radius: 12px;
        background: linear-gradient(180deg, #fffdf8 0%, #fffaf2 100%);
        box-shadow: 0 2px 6px rgba(0,0,0,0.08);
        padding: 16px 18px 20px 18px;
        margin: 12px 0;
        transition: box-shadow 0.2s ease;
    }

        .ac-required-card:hover {
            box-shadow: 0 4px 10px rgba(0,0,0,0.12);
        }

    /* === Required Card Styling (minimal + red dashed) === */
    .ac-required-card {
        position: relative;
        border: 2px dashed #d93025; /* red dashed border */
        border-radius: 10px;
        background: transparent; /* no fill color */
        padding: 16px 18px 20px 18px;
        margin: 14px 0;
    }

    /* === Banner Header === */
    .ac-required-banner {
        display: flex;
        align-items: center;
        justify-content: center;
        background: #fdecea; /* soft red-tinted background */
        color: #b71c1c; /* darker red for text */
        border: 1px solid #f5c6cb; /* subtle matching border */
        border-radius: 6px;
        padding: 6px 12px;
        font-size: 13px;
        font-weight: 600;
        margin-bottom: 14px;
        box-shadow: inset 0 1px 0 rgba(255,255,255,0.5);
    }

        /* Optional: small emoji prefix */
        .ac-required-banner::before {
            content: "⚠️";
            margin-right: 6px;
        }

    /* === Required Field Markers === */
    .ac-required-field label .ac-required-indicator {
        color: #d93025;
        font-weight: bold;
    }

    /* === Inputs inside required cards === */
    .ac-required-card .ac-input-container input,
    .ac-required-card .ac-input-container select,
    .ac-required-card .ac-input-container textarea {
        border: 1px solid #f1a6a0;
        transition: border-color 0.2s ease;
    }

        .ac-required-card .ac-input-container input:focus,
        .ac-required-card .ac-input-container select:focus,
        .ac-required-card .ac-input-container textarea:focus {
            border-color: #d93025;
            outline: none;
        }

    /* === Submit Button inside required cards === */
    .ac-required-card .ac-pushButton {
        background: linear-gradient(180deg, #0078d7 0%, #005fa3 100%);
        border: none;
        color: white;
        font-weight: 600;
        border-radius: 6px;
        box-shadow: 0 1px 3px rgba(0,0,0,0.15);
        transition: background 0.2s ease, box-shadow 0.2s ease;
    }

        .ac-required-card .ac-pushButton:hover {
            background: linear-gradient(180deg, #008fee 0%, #006cc2 100%);
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        }

</style>
